import math
from itertools import combinations

function mana_n_rage:gear/midnight_spear/midnight_zone_tick_particle:
    # 1) vertices
    phi = (1 + math.sqrt(5)) / 2
    invphi = 1 / phi
    V = [
        (+1, +1, +1),(+1, +1, -1),(+1, -1, +1),(+1, -1, -1),
        (-1, +1, +1),(-1, +1, -1),(-1, -1, +1),(-1, -1, -1),
        (0,  invphi,  phi),(0,  invphi, -phi),(0, -invphi,  phi),(0, -invphi, -phi),
        ( invphi,  phi, 0),( invphi, -phi, 0),(-invphi,  phi, 0),(-invphi, -phi, 0),
        ( phi, 0,  invphi),( phi, 0, -invphi),(-phi, 0,  invphi),(-phi, 0, -invphi),
    ]
    n = len(V)

    # 2) pairwise distances
    def dist(a,b):
        return math.sqrt((a[0]-b[0])**2 + (a[1]-b[1])**2 + (a[2]-b[2])**2)

    # initialize n x n zero matrix (Bolt-friendly)
    dists = []
    i = 0
    while i < n:
        row = []
        j = 0
        while j < n:
            row.append(0.0)
            j = j + 1
        dists.append(row)
        i = i + 1

    all_nonzero = []
    i = 0
    while i < n:
        j = i + 1
        while j < n:
            d = dist(V[i], V[j])
            dists[i][j] = d
            dists[j][i] = d
            all_nonzero.append(d)
            j = j + 1
        i = i + 1

    # 3) infer adjacency: use the minimum nonzero distance as edge length
    dmin = min(all_nonzero)
    tol = 1e-6

    # build edges without list comprehension / combinations
    edges = []
    i = 0
    while i < n:
        j = i + 1
        while j < n:
            if dists[i][j] <= dmin*(1+1e-3):
                edges.append((i, j))
            j = j + 1
        i = i + 1

    # if that misses edges due to FP, widen tolerance:
    if len(edges) < 30:  # dodecahedron has 30 edges
        edges = []
        i = 0
        while i < n:
            j = i + 1
            while j < n:
                if dists[i][j] <= dmin*(1+0.02):
                    edges.append((i, j))
                j = j + 1
            i = i + 1

    # provide the alias used later
    edge_list = edges

    # 4) approximate max-cut (greedy local search) — deterministic and fast (replaces expensive full 2^n brute force)
    # initialize alternating partition (0101...)
    best_mask = 0
    i = 0
    while i < n:
        if (i % 2) == 1:
            best_mask = best_mask | (1 << i)
        i = i + 1

    # helper to compute cut size for a mask
    def compute_cut(mask):
        total = 0
        k = 0
        while k < len(edge_list):
            pair = edge_list[k]
            ii = pair[0]
            jj = pair[1]
            if ((mask >> ii) & 1) != ((mask >> jj) & 1):
                total = total + 1
            k = k + 1
        return total

    best_cut = compute_cut(best_mask)

    # greedy improvement: flip single vertices to improve cut, bounded iterations
    improved = True
    iters = 0
    max_iters = 1000    # safety bound — adjust if you want more refinement
    while improved and iters < max_iters:
        improved = False
        i = 0
        while i < n:
            new_mask = best_mask ^ (1 << i)   # flip vertex i
            new_cut = compute_cut(new_mask)
            if new_cut > best_cut:
                best_cut = new_cut
                best_mask = new_mask
                improved = True
            i = i + 1
        iters = iters + 1

    # 5) output partition (no list comprehensions)
    A_idx = []
    B_idx = []
    i = 0
    while i < n:
        bit = (best_mask >> i) & 1
        if bit == 1:
            A_idx.append(i)
        else:
            B_idx.append(i)
        i = i + 1

    A = []
    i = 0
    while i < len(A_idx):
        A.append(V[A_idx[i]])
        i = i + 1

    B = []
    i = 0
    while i < len(B_idx):
        B.append(V[B_idx[i]])
        i = i + 1

    # debug prints (optional)
    print("Best cut size:", best_cut, "of", len(edge_list), "edges")
    print("Group A indices:", A_idx)
    print("Group B indices:", B_idx)
    print("Group A coords:", A)
    print("Group B coords:", B)

    k = 5.0  # scale factor

    scaled_a = []
    i = 0
    while i < len(A):
        v = A[i]
        scaled_a.append((k*v[0], k*v[1], k*v[2]))
        i = i + 1

    scaled_b = []
    i = 0
    while i < len(B):
        v = B[i]
        scaled_b.append((k*v[0], k*v[1], k*v[2]))
        i = i + 1

    num_copies = 10

    # compact rotation helper (apply X then Y then Z)
    def rotate_apply(x0, y0, z0, cx, sx, cy, sy, cz, sz):
        # rotate X (pitch)
        y1 = y0 * cx - z0 * sx
        z1 = y0 * sx + z0 * cx
        x1 = x0
        # rotate Y (yaw)
        x2 = x1 * cy + z1 * sy
        z2 = -x1 * sy + z1 * cy
        y2 = y1
        # rotate Z (roll)
        x3 = x2 * cz - y2 * sz
        y3 = x2 * sz + y2 * cz
        z3 = z2
        return (x3, y3, z3)
    for frame in range(20):
        brightness = 0.5 + 0.5*math.sin(math.radians((frame/19)*360))
        invbrightness = 0.5 - 0.5*math.sin(math.radians((frame/19)*180))
        execute if score @s MidnightZoneParticleTick matches frame:
            for copy in range(num_copies):
                yaw_deg = copy * (360.0 / num_copies)
                pitch_deg = copy * 13.0
                roll_deg = copy * 23.0

                yaw = math.radians(yaw_deg)
                pitch = math.radians(pitch_deg)
                roll = math.radians(roll_deg)

                cy = math.cos(yaw)
                sy = math.sin(yaw)
                cx = math.cos(pitch)
                sx = math.sin(pitch)
                cz = math.cos(roll)
                sz = math.sin(roll)

                # iterate both groups using same rotation code; choose color per group
                for coord_group, col in ((scaled_a, brightness), (scaled_b, invbrightness)):
                    for v in coord_group:
                        x0 = v[0]
                        y0 = v[1]
                        z0 = v[2]
                        xr, yr, zr = rotate_apply(x0, y0, z0, cx, sx, cy, sy, cz, sz)
                        # round values for command emission
                        xr = round(xr, 4)
                        yr = round(yr, 4)
                        zr = round(zr, 4)
                        c = col
                        particle minecraft:dust{scale:1f,color:[c,c,c]} ~xr ~yr ~zr 0 0 0 0 1
    execute as @s run scoreboard players add @s MidnightZoneParticleTick 1
    execute as @s if score @s MidnightZoneParticleTick matches 19.. run scoreboard players set @s MidnightZoneParticleTick 0
             
